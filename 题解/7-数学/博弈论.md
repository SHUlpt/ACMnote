## [树上博弈](https://ac.nowcoder.com/acm/contest/3005/F)：【奇偶性】

> - 题目：
>
>   现有一个由`n`个点，`n-1`条边组成的树，其中1号点位根节点。甲乙两人在开始时分在在树上两个不同的节点上，甲先走。每次移动只能移动到没有人的空节点上，如果谁移动不了，就输掉了游戏。
>   求有多少种游戏开始方式，能够使得甲存在一种一定获胜的最优策略。
>
> - 输入描述：
>
>   第一行一个整数`n`代表树的结点
>   第二行`n-1`个整数$p_1,p_2,\dots p_n$，分别代表`2,3,...n`号点的父亲节点编号
>
> - Input：
>
>   ```
>   3
>   1 2
>   ```
>
> - Output：
>
>   ```
>   2
>   （当且仅当甲在1号点，乙在3号点，或者甲在3号点，乙在1号点时，甲才获胜。）
>   ```

### 题解

首先，输掉的唯一情况是自己唯一一条边上有人，所以自己一定是在叶子上。

设两人之间距离为D，每次行动都会让D增加1或减少1，也就是每次移动都会改变奇偶性。
假设最初，在甲移动之前，D为偶数，那么每次轮到甲移动时，D始终为偶数，而乙则始终为奇数。

对于移动策略，甲总是可以选择向乙的方向移动，乙最终必然会移动到叶子上。
因为最终不能移动时一定有$D=1$，所以如果初始距离为偶数，则甲赢，否则乙赢。
因此只需要**求出深度为奇数的点和深度为偶数的点的数量即可**。

```c++
const int maxn = 1e6 + 10;
int n, p[maxn], depth[maxn];
ll cnt[2];
int main()
{
    cin >> n;
    depth[1] = 0;
    cnt[0] = 1;
    for (int i = 2; i <= n; i++) {
        cin >> p[i];
        depth[i] = depth[p[i]] ^ 1;	//用异或来区分与父亲节点的奇偶关系
        cnt[depth[i]]++;
    }
    cout << cnt[0] * (cnt[0] - 1) + cnt[1] * (cnt[1] - 1) << endl;
    return 0;
}
```



## [Enjoy the game](https://ac.nowcoder.com/acm/contest/3006/E)：【二进制】

> - 题目:
>
>   初始共有`n`张卡牌，先手第一步至少拿1张，至多拿`n-1`张。接下来每一步，双方至少要拿1张，至多拿等同于上一步对方拿的牌数的牌，拿走最后一张牌的人将取得游戏的胜利。`Bob`先手，`Alice`后手。
>
> - 输入：
>
>   $2\le n \le 10^{18}$
>
>   ```
>   2
>   ```
>
> - 输出：
>
>   ```
>   Alice
>   ```

### 题解

找规律可以发现，当张数是$2^n$时，后手必赢。

首先如果有奇数张牌，那么先手的人可以选择只拿一张，那么一定会赢。
如果不是$2^n$的情况，先手直接拿等同于其二进制最低位的数量的张数，因为后手拿的牌不能大过先手的，所以此时一定会有前面的二进制位进行拆分，因为拆分会得到两份，所以先手总能赢。
所以如果是$2^n$的情况，先手时就会让前面的二进制位拆分，所以后手能赢。

```c++
int main()
{
    long long n;
    scanf("%lld", &n);
    long long tmp = 1;
    for (int i = 1; i <= 60; i++)
    {
        if ((tmp<<i) == n)
        {
            printf("Alice\n");
            return 0;
        }
    }
    printf("Bob\n");
    return 0;
}
```

