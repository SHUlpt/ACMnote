## 数学-博弈论

### 巴什博弈

>  有一堆石子，总数为n，每次可以取1~m个石子，不能取的一方输

如果能够给对手一个m+1堆，就能保证无论对手怎么取都能赢
所以先手应设法取一个数使剩下石子数为**k(m+1)**

```c++
int n,m;
cin >> n >> m;
if(n % (m+1)) cout << "First"; //可以把k*(m+1)这个状态给对面
else cout << "Second"; //到自己手上状态是k*(m+1)
```

如果$n\%(m+1)$不为0，因为余数一定小于等于m，所以先手取走余数后就只剩下$k(m+1)$个石子。
假设对手取x个，自己只需要取$m+1-x$个，就能使状态再次回归到$k(m+1)$

#### 变形：最后取的输

只要留一块给对面就能赢

```c++
if((n-1) % (m+1)) cout << "First";
else cout << "Second";
```



### 威佐夫博弈

> 有两堆若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，每次至少取一个，最后取光者获胜

用`a[k],b[k]`表示两堆物品的数量并称其为局势，称必输局势为**奇异局势**，前几个奇异局势为$(0,0),(1,2),(3,5),(4,7)$

**公式**：$a[k]=[k*(1+\sqrt 5)/2],\, b[k]=a[k]+k$

**性质**：

1. 每个自然数只会出现一个奇异局势
2. 奇异局势在一次操作后会变成非奇异局势
3. 非奇异局势可以在一次操作后变为奇异局势

因为$k=b-a$，所以直接判断小的那一堆能后满足`a[k]`的公式

```c++
int a,b;
cin >> a >> b;
if(a>b) swap(a,b);
int k=b-a;
if(a==floor(k*(1.0+sqrt(5.0))/2)) cout << 0 << endl; //必败态
else cout << 1 << endl;	//必胜态
```



### 尼姆博弈

> 有k堆若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，拿走最后一个石子的玩家获胜

当拿到一个异或和为0且没有取完的状态时，因为至少取一个，所以取任意一个数，都会使二进制中有1出现，就代表石子还没有取完。而对方就可以取一个数使剩下的石子数异或和为0，**即维护异或和为0的状态**

**公式**：若$a_1\oplus a_2 \oplus a_3\dots \oplus a_n \ne 0$，则先手必胜

```c++
int ans=0;
for(int i=1;i<=n;i++) ans^=a[i];
if(ans) cout << 1 << endl; //先手胜出
else cout << 0 << endl;
```



### 斐波那契博弈

> 一堆石子，两个人轮流取走一定的石子，拿走最有一个石子的玩家获胜，遵循如下规则：
>
> 1. 第一次取不能取完，至少取1颗
> 2. 从第二次开始，每个人取的石子数至少为1，至多为对手刚取的石子数的两倍

**公式**：当n为斐波那契数时，先手必败